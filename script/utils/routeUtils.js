function getPointAtPercentage(t,e){if(!t||!t.length)return[0,0];if(e<=0)return parseCoordinate(t[0]);if(e>=100)return parseCoordinate(t[t.length-1]);try{const n=t.map((t=>parseCoordinate(t))),{segments:a,totalDistance:o}=calculateSegmentDistances(n),r=o*(e/100),i=a.find((t=>t.accumulatedDistance>=r));if(!i)return n[n.length-1];const s=0===i.startIndex?0:a[i.startIndex-1].accumulatedDistance,c=(r-s)/i.distance;return[i.startPoint[0]+(i.endPoint[0]-i.startPoint[0])*c,i.startPoint[1]+(i.endPoint[1]-i.startPoint[1])*c]}catch(e){return parseCoordinate(t[0])}}function calculateSegmentDistances(t){const e=[];let n=0;for(let a=0;a<t.length-1;a++){const o=calculateDistance(t[a],t[a+1]);n+=o,e.push({startIndex:a,endIndex:a+1,startPoint:t[a],endPoint:t[a+1],distance:o,accumulatedDistance:n})}return{segments:e,totalDistance:n}}function parseCoordinate(t){if(!t)return[0,0];if(Array.isArray(t)&&"number"==typeof t[0]&&"number"==typeof t[1]&&!isNaN(t[0])&&!isNaN(t[1]))return t;try{let e,n;if(Array.isArray(t))e=parseFloat(String(t[0]).replace(/([0-9.]+)(.*)/,"$1")),n=parseFloat(String(t[1]).replace(/([0-9.]+)(.*)/,"$1"));else{if("string"!=typeof t)return[0,0];{const a=t.split(",");e=parseFloat(a[0].trim()),n=parseFloat(a[1].trim())}}return isNaN(e)||isNaN(n)?[0,0]:[e,n]}catch(t){return[0,0]}}function calculateDistance(t,e){try{const[n,a]=parseCoordinate(t),[o,r]=parseCoordinate(e),i=t=>t*Math.PI/180,s=6371e3,c=i(r-a),l=i(o-n),d=Math.sin(c/2)*Math.sin(c/2)+Math.cos(i(a))*Math.cos(i(r))*Math.sin(l/2)*Math.sin(l/2);return s*(2*Math.atan2(Math.sqrt(d),Math.sqrt(1-d)))}catch(t){return 0}}function calculateRouteLength(t){if(!t||t.length<2)return 0;try{const e=t.map((t=>parseCoordinate(t)));let n=0;for(let t=0;t<e.length-1;t++)n+=calculateDistance(e[t],e[t+1]);return n}catch(t){return 0}}function isValidCoordinate(t){if(!t||!Array.isArray(t)||t.length<2)return!1;let e,n;if("string"==typeof t[0]&&"string"==typeof t[1])try{e=parseFloat(t[0].replace(/([0-9.]+)(.*)/,"$1")),n=parseFloat(t[1].replace(/([0-9.]+)(.*)/,"$1"))}catch(t){return!1}else[e,n]=t;return!isNaN(e)&&!isNaN(n)&&(!(e<-180||e>180)&&!(n<-90||n>90))}function getRoutePointsBetweenCoordinates(t,e,n){if(!t||!t.coordinate||!t.coordinate.length)return[];try{const a=t.coordinate.map((t=>parseCoordinate(t))),o=(calculateRouteLength(a),parseCoordinate(e)),r=parseCoordinate(n);let i=1/0,s=1/0,c=-1,l=-1,d=null,u=null,p=[],g=0;for(let t=0;t<a.length-1;t++){const e=calculateDistance(a[t],a[t+1]);g+=e,p.push({startIndex:t,endIndex:t+1,startPoint:a[t],endPoint:a[t+1],distance:e,accumulatedDistance:g});const n=projectPointToSegment(o,a[t],a[t+1]),P=projectPointToSegment(r,a[t],a[t+1]);n.distance<i&&(i=n.distance,c=t,d=n.point),P.distance<s&&(s=P.distance,l=t,u=P.point)}if(-1===c||-1===l)return[];let P=0,h=0;for(let t=0;t<c;t++)P+=p[t].distance;const m=p[c],f=calculateDistance(m.startPoint,m.endPoint);P+=calculateDistance(m.startPoint,d)/f*m.distance;for(let t=0;t<l;t++)h+=p[t].distance;const w=p[l],y=calculateDistance(w.startPoint,w.endPoint);h+=calculateDistance(w.startPoint,u)/y*w.distance;const x=P<=h,D=x?P:h,C=x?h:P,M=[];M.push(x?e:n);const A=10;let R=D;for(let t=0;t<p.length;t++){const e=p[t],n=e.accumulatedDistance-e.distance,a=e.accumulatedDistance;if(a<=D||n>=C)continue;const o=Math.max(D,n),r=Math.min(C,a),i=r-o,s=Math.max(1,Math.floor(i/A));for(let a=0;a<=s;a++){if(t===(x?c:l)&&0===a&&o===D)continue;if(t===(x?l:c)&&a===s&&r===C)continue;const d=o+a*i/s,u=(d-n)/e.distance,p=[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])*u,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])*u];M.push(p),R=d}}M.push(x?n:e);return x?M:M.reverse()}catch(t){return[]}}function projectPointToSegment(t,e,n){const[a,o]=t,[r,i]=e,[s,c]=n,l=s-r,d=c-i,u=l*l+d*d;if(0===u)return{point:e,distance:calculateDistance(t,e)};const p=Math.max(0,Math.min(1,((a-r)*l+(o-i)*d)/u)),g=[r+p*l,i+p*d];return{point:g,distance:calculateDistance(t,g)}}function showPercentageRangePoints(t,e,n){const a=window.mapPointSelectedRoute;if(a)try{"function"==typeof window.clearAllMarkers&&window.clearAllMarkers(t);const o=a.coordinate;if(!o||!o.length)return;const r=o.map((t=>parseCoordinate(t))),i=calculateRouteLength(r),s=i*(e/100),c=i*(n/100);let l=[],d=0;for(let t=0;t<r.length-1;t++){const e=calculateDistance(r[t],r[t+1]);d+=e,l.push({startIndex:t,endIndex:t+1,startPoint:r[t],endPoint:r[t+1],distance:e,accumulatedDistance:d})}let u=0,p=0;for(;p<l.length&&l[p].accumulatedDistance<s;)u=l[p].accumulatedDistance,p++;const g=[];if(p<l.length){const t=l[p],e=(s-(t.accumulatedDistance-t.distance))/t.distance,n=[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])*e,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])*e];g.push(n);let a=p;for(;a<l.length&&l[a].accumulatedDistance<=c;)g.push(r[l[a].endIndex]),a++;if(a<l.length){const t=l[a],e=(c-(t.accumulatedDistance-t.distance))/t.distance,n=[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])*e,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])*e];g.push(n)}}else g.push(r[r.length-1]);const P=new mapboxgl.LngLatBounds;Array.isArray(window.mapPointMarkersArray)||(window.mapPointMarkersArray=[]),g.forEach(((a,o)=>{const r=document.createElement("div");r.className="custom-marker range-marker",r.style.width="8px",r.style.height="8px",r.style.borderRadius="50%",r.style.backgroundColor="#0088ff",r.style.border="2px solid white";const i=e+(n-e)*(o/Math.max(1,g.length-1)),s=new mapboxgl.Marker(r).setLngLat(a).setPopup((new mapboxgl.Popup).setHTML(`\n                    <strong>範圍點 #${o+1}</strong><br>\n                    大約位置: ${i.toFixed(1)}%<br>\n                    坐標: [${a[0].toFixed(6)}, ${a[1].toFixed(6)}]\n                `)).addTo(t);window.mapPointMarkersArray.push(s),isValidCoordinate(a)&&P.extend(a)})),t.fitBounds(P,{padding:50})}catch(t){}}function showIncrementPoints(t,e){const n=window.mapPointSelectedRoute;if(n)try{"function"==typeof window.clearAllMarkers&&window.clearAllMarkers(t);const a=n.coordinate;if(!a||!a.length)return;const o=a.map((t=>parseCoordinate(t))),r=calculateRouteLength(o),i=[],s=new mapboxgl.LngLatBounds;let c=[],l=0;for(let t=0;t<o.length-1;t++){const e=calculateDistance(o[t],o[t+1]);l+=e,c.push({startIndex:t,endIndex:t+1,startPoint:o[t],endPoint:o[t+1],distance:e,accumulatedDistance:l})}for(let t=0;t<=100;t+=e){const e=r*(t/100),n=c.find((t=>t.accumulatedDistance>=e));if(n){const a=0===n.startIndex?0:c[n.startIndex-1].accumulatedDistance,o=(e-a)/n.distance,r=[n.startPoint[0]+(n.endPoint[0]-n.startPoint[0])*o,n.startPoint[1]+(n.endPoint[1]-n.startPoint[1])*o];i.push({percentage:t,point:r}),isValidCoordinate(r)&&s.extend(r)}else if(100===t){const t=o[o.length-1];i.push({percentage:100,point:t}),isValidCoordinate(t)&&s.extend(t)}}Array.isArray(window.mapPointMarkersArray)||(window.mapPointMarkersArray=[]),i.forEach((n=>{const{percentage:a,point:o}=n,r=document.createElement("div");r.className="custom-marker increment-marker",r.style.width="10px",r.style.height="10px",r.style.borderRadius="50%",r.style.backgroundColor="#ff4500",r.style.border="2px solid white";const i=new mapboxgl.Marker(r).setLngLat(o).setPopup((new mapboxgl.Popup).setHTML(`\n                    <strong>${a}% 位置</strong><br>\n                    增量: ${e}%<br>\n                    坐標: [${o[0].toFixed(6)}, ${o[1].toFixed(6)}]\n                `)).addTo(t);window.mapPointMarkersArray.push(i)})),t.fitBounds(s,{padding:50})}catch(t){}}"undefined"!=typeof module&&module.exports?module.exports={getPointAtPercentage,calculateSegmentDistances,parseCoordinate,calculateDistance,calculateRouteLength,isValidCoordinate,showPercentageRangePoints,showIncrementPoints,getRoutePointsBetweenCoordinates}:"undefined"!=typeof window&&(window.routeUtils={getPointAtPercentage,calculateSegmentDistances,parseCoordinate,calculateDistance,calculateRouteLength,isValidCoordinate,showPercentageRangePoints,showIncrementPoints,getRoutePointsBetweenCoordinates});